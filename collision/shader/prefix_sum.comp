#version 460 core 

#define N 2048
#define CONSTS 0
#define COUNTS 0
#define NEXT_ID 0
#define SUMS 5
#define RADIX_SUM_DATA 6
#define RADICES_PER_WG 4
#define NUM_RADICES 256
#define BARRIER groupMemoryBarrier(); barrier()
#define ACQURE_LOCK while(atomicCompSwap(mutex, 1, 0) == 0){}
#define RELEASE_LOCK atomicExchange(mutex, 1)

layout(local_size_x=1024) in;

layout(binding = CONSTS) uniform Consts{
	uint byte;
	uint R;
	uint Radix;
	uint Num_Groups_per_WorkGroup;
	uint Num_Elements_per_WorkGroup;
	uint Num_Elements_Per_Group;
	uint Num_Elements;
	uint Num_Radices_Per_WorkGroup;
	uint Num_Groups;
};

layout(binding=NEXT_ID) uniform atomic_uint nextId;

layout(std430, binding=COUNTS) buffer Counts{
	uint counts[];
};

layout(std430, binding=SUMS) buffer Sums{
	uint sums[];
};

layout(std430, binding=RADIX_SUM_DATA)  buffer RadixSumData{
    uint mutex;
	uint running_sum;
};

shared uint local_counts[N];
shared uint local_sums[RADICES_PER_WG];


void main(){
	uint thid = gl_LocalInvocationIndex;
	
	for(int i = 0; i < Num_Radices_Per_WorkGroup; i++){	// TODO split into 4 group of 256 threads 
		uint cOffset = gl_WorkGroupID.x * (Num_Radices_Per_WorkGroup * Num_Groups) + i * Num_Groups;

		local_counts[2 * thid] = counts[2 * thid + cOffset];

		local_counts[2 * thid + 1] = counts[2 * thid + 1 + cOffset];

		uint offset = 1;
		for(uint d = N >> 1; d > 0; d >>= 1){
			BARRIER;
			if(thid < d){
				uint ai = offset * ( 2 * thid+1) -1;
				uint bi = offset * ( 2 * thid+2) -1;
				local_counts[bi]  += local_counts[ai];
			}
			offset *= 2;
		}

		if(thid == 0){  
			sums[gl_WorkGroupID.x * Num_Radices_Per_WorkGroup + i] = local_counts[N - 1];
			local_counts[N - 1] = 0;
		}

	    for(uint d = 1; d < N; d *= 2){
			offset >>= 1;
			BARRIER;
			if(thid < d){
				uint ai = offset * (2 * thid + 1) - 1;
				uint bi = offset * (2 * thid + 2) - 1;
				uint t = local_counts[ai];
				local_counts[ai] = local_counts[bi];
				local_counts[bi] += t;
			}
		}
		BARRIER;

		counts[2 * thid + cOffset] = local_counts[2 * thid];
		counts[2 * thid + 1 + cOffset] = local_counts[2 * thid + 1];

		BARRIER;
	}

//	if(thid == 0){
//		ACQURE_LOCK;
//		uint workGroupId = atomicCounterIncrement(nextId);
//		for(int i = 0; i < 4; i++){
//			uint id =  workGroupId * Num_Radices_Per_WorkGroup + i;
//			atomicExchange(running_sum, atomicExchange(sums[id], running_sum));
//			atomicAdd(sums[id + 1], running_sum);
//		}
//		RELEASE_LOCK;
//	}
}