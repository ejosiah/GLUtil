#version 450 core

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(rgba32f, binding=0) uniform image2D image;

layout(binding = 0) uniform samplerCube environmentMap;
layout(binding=1) uniform sampler2D checkerboard;

const int MAX_BOUNCES = 5;
const float RRThreshold = 0.0001;
int rayCount = 0;
int shadowRayCount = 0;

uniform vec3 camPos;
uniform vec3 worldCenter;
uniform float worldRadius;
uniform int numPlanes = 0;
uniform int numSpheres = 0;
uniform int bounces = 5;

#pragma include("ray_tracing_common.glsl")
#pragma include("ray_tracing_model.glsl")
#pragma include("ray_shape_test.glsl")
#pragma include("lights.glsl")
#pragma include("hash.glsl")


layout(std430, binding=1) buffer RAY_SSB0{
	Ray rays[];
};

layout(std430, binding=2) buffer LIGHT_SOURCE_SSBO{
	LightSource light[];
};

layout(std430, binding=3) buffer MATERIAL_SSB0{
	Material material[];

};

layout(std430, binding=4) buffer PLANE_SSB0{
	Plane plane[];
};

layout(std430, binding=5) buffer SPHERE_SSB0{
	Sphere sphere[];
};

layout(std430, binding=6) buffer TRIANGLE_SSB0{
	Triangle triangle[];
};

layout(std430, binding=7) buffer SHADING_SSB0{
	Shading shading[];
};

#pragma include("interaction.glsl")
#pragma include("scene_test.glsl")

int globalIndex(){
	ivec3 size = ivec3(gl_WorkGroupSize * gl_NumWorkGroups);
	ivec3 pos = ivec3(gl_GlobalInvocationID);

	return pos.z * (size.y * size.x) + (pos.y * size.x) + pos.x;
}

vec3 shade(SurfaceInteration interact){
	Ray shadow_ray;
	float pdf;
	vec3 wi;
	vec3 I = sample_Li(light[0], interact, vec2(0), wi, pdf, shadow_ray);

	if(pdf == 0 || isBlack(I)) return vec3(0);

	vec3 p = interact.p;
	vec3 n = interact.n;
	vec3 wo = normalize( camPos - p);
	vec3 h = normalize(wi + wo);

	vec3 ka = vec3(0);
	vec3 kd = interact.color.xyz;
	vec3 ks = I;
	float f = 5.0;

	if(interact.matId >= 0){
		Material mat = material[interact.matId];
		ka = mat.diffuse.xyz;
		kd = mat.diffuse.xyz;
		ks = mat.specular.xyz;
		f = mat.shine;
	}
	if (interact.shape == PLANE) {
		ka = vec3(0);
		kd = texture(checkerboard, interact.uv).xyz;
		ks = vec3(1);
		f = 20.0;
	}

	float wi_dot_n = dot(wi, n);

	//vec3 Li = ka * vec3(0.3) + I;
	vec3 Li = vec3(0);

	Li += I * max(0, wi_dot_n) * kd;
	Li += I * max(0, pow(dot(n, h), f)) * ks;

	float visibility = 1.0;
	if(wi_dot_n > 0 && anyHit(shadow_ray)){
		shadowRayCount++;
		visibility = 0.3;
	}

//	return  wi_dot_n > 0 && inShadow ? mix(Li, vec3(0), 0.7) : Li;
	return  mix(vec3(0), Li, visibility);
}

vec3 doReflect(vec3 wo, out vec3 wi, SurfaceInteration interact, out float pdf){
	pdf = 1.0;
	wi = reflect(-wo, interact.n);
	return vec3(0.7);
}

vec3 doRefract(vec3 wo, out vec3 wi, SurfaceInteration interact, out float pdf){
	bool entering = dot(wo, interact.n) > 0;
	float etaI = entering ? interact.n1 : interact.n2;
	float etaT = entering ? interact.n2 : interact.n1;
	float eta = etaI / etaT;

	pdf = 1.0;

	vec3 n = interact.n;
	n = flipNormal(wo, n);
	wi = refract(-wo, n, eta);
	return vec3(1);
}

vec3 trace1(Ray ray);
vec3 trace2(Ray ray);

vec3 trace(Ray ray){
	vec3 color = vec3(0);
	vec3 mask = vec3(1);
	vec3 accum_f = vec3(1);
	float accum_pdf = 1;
	Ray r = ray;
	for(int i = 0; i < bounces; i++){
		if(accum_pdf < RRThreshold) break;
		HitInfo hit;
		vec3 wo = -r.direction.xyz;
		vec3 wi;
		if (intersectScene(r, hit)){
			SurfaceInteration interact;
			intialize(hit, r, interact);
			if(hasBsdf(interact, SPECIULAR_REFLECT)){
				float pdf;
				accum_f *= doReflect(wo, wi, interact, pdf);
				accum_pdf *= pdf;

			}else if(hasBsdf(interact, SPECULAR_TRANSMISSION)){
			// mask *= fresnel
				float pdf;
				accum_f *= doRefract(wo, wi, interact, pdf);
				accum_pdf *= pdf;
			}else if(hasBsdf(interact, FRESNEL_SPECULAR)){
				vec3 n = interact.n;
				float pdf_local;
				float cos0 = dot(wo, n);
				float f  = fresnel(cos0, interact.n1, interact.n2);
				
				vec3 wi_r;
				float pdf_r;
				vec3 R = doReflect(wo, wi_r, interact, pdf_r);
				Ray rr = spawnRay(interact, wi_r);

				color += accum_f * f * R * trace1(rr) / (pdf_r * f * accum_pdf);
				float ks = 1 - f;

				float pdf;
				accum_f *= doRefract(wo, wi, interact, pdf);
				accum_pdf *= pdf;
			}
			else{
				color += accum_f * shade(interact) / accum_pdf;
				break;
			}
			r = spawnRay(interact, wi);
		}
		else{
			color += accum_f * texture(environmentMap, r.direction.xyz).rgb / accum_pdf;
			break;
		}
	}
	return color;
}

vec3 trace1(Ray ray){
	vec3 color = vec3(0);
	vec3 mask = vec3(1);
	vec3 accum_f = vec3(1);
	float accum_pdf = 1;
	Ray r = ray;
	for(int i = 0; i < bounces * 0.5; i++){
		if(accum_pdf < RRThreshold) break;
		rayCount++;
		HitInfo hit;
		vec3 wo = -r.direction.xyz;
		vec3 wi;
		if (intersectScene(r, hit)){
			SurfaceInteration interact;
			intialize(hit, r, interact);
			if(hasBsdf(interact, SPECIULAR_REFLECT)){
				float pdf;
				accum_f *= doReflect(wo, wi, interact, pdf);
				accum_pdf *= pdf;

			}else if(hasBsdf(interact, SPECULAR_TRANSMISSION)){
			// mask *= fresnel
				float pdf;
				accum_f *= doRefract(wo, wi, interact, pdf);
				accum_pdf *= pdf;
			}else if(hasBsdf(interact, FRESNEL_SPECULAR)){
				vec3 n = interact.n;
				float pdf_local;
				float cos0 = dot(wo, n);
				float f  = fresnel(cos0, interact.n1, interact.n2);
				
				vec3 wi_r;
				float pdf_r;
				vec3 R = doReflect(wo, wi_r, interact, pdf_r);
				Ray rr = spawnRay(interact, wi_r);
				color += accum_f * f * R * trace2(rr) / (pdf_r * f * accum_pdf);

				float pdf;
				accum_f *= doRefract(wo, wi, interact, pdf);
				accum_pdf *= pdf * (1 - f);
			}
			else{
				color += accum_f * shade(interact) / accum_pdf;
				break;
			}
			r = spawnRay(interact, wi);
		}
		else{
			color += accum_f * texture(environmentMap, r.direction.xyz).rgb / accum_pdf;
			break;
		}
	}
	return color;
}

vec3 trace2(Ray ray){
	vec3 color = vec3(0);
	Ray r = ray;
	HitInfo hit;
	if (intersectScene(r, hit)){
		SurfaceInteration interact;
		intialize(hit, r, interact);
		if(!hasFlag(interact, SPECULAR_TRANSMISSION | SPECIULAR_REFLECT | FRESNEL_SPECULAR)){
			color = shade(interact);
		}else{
			color = vec3(0);
		}
	}else{
		color = texture(environmentMap, r.direction.xyz).rgb;
	}
	

	return color;
}

void main(){
	int index = globalIndex();
	Ray ray = rays[index];
	
	vec3 color = trace(ray);

	color /= color + vec3(1.0);
	color = pow(color, vec3(1.0/2.2));

	imageStore(image, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1));
}
