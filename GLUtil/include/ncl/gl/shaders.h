#pragma once
#include <iostream>
const std::string basic_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(location=0) out vec4 vFragColor; //fragment shader output\n \nsmooth in vec4 color; //interpolated colour from the vertex shader\n\nvoid main() { \n	//set the input colour from the vertex shader as fragment shader output\n	vFragColor = color;	 \n}\n";
const std::string bling_phong_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\n#define PI 3.14159265359 \n#define MAX_SCENE_LIGHTS 10\n\nuniform mat4 M;\nuniform mat4 V;\nuniform mat4 P;\nuniform mat4 MVP;\n\nlayout(location=0) in vec3 position;\nlayout(location=1) in vec3 normal;\nlayout(location=2) in vec3 tangent;\nlayout(location=3) in vec3 bitangent;\nlayout(location=4) in vec4 color;\nlayout(location=5) in vec2 uv;\nlayout(location=8) in mat4 xform;\n\nstruct Light{\n	vec3 position;\n	vec3 intensity;\n};\n\nlayout(std430, binding=0) buffer SCENE_SSBO{\n	vec3 eyes;\n	Light lights[MAX_SCENE_LIGHTS];\n};\n\nuniform int numLights = 6;\n\nout VERTEX{\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec3 tangent;\n    smooth vec3 bitangent;\n	smooth vec2 uv;\n} vertex_out;\n\n\nvoid main(){\n	\n	mat3 nform = inverse(transpose(mat3(M * xform)));\n	vec3 n = nform * normal;\n	vec3 t = nform * tangent;\n	vec3 b = nform * bitangent;\n	vertex_out.normal = n;\n	vertex_out.tangent = t;\n	vertex_out.bitangent = b;\n\n	mat3 olm = mat3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);\n\n	vec4 worldPos = M * xform * vec4(position, 1.0);\n\n	vertex_out.position = worldPos.xyz;\n	\n	vertex_out.uv = uv;\n\n	gl_Position = P * V * worldPos;\n}\n";
const std::string brdf_vert_shader = "#version 450 core\n\nlayout(location=0) in vec3 position;\nlayout(location=5) in vec2 uv;\n\nsmooth out vec2 texCoord;\n\nvoid main(){\n	texCoord = uv;\n	gl_Position = vec4(position, 1.0);\n}\n";
const std::string bsdf_frag_shader = "#version 450 core\n\nconst float PI = 3.14159265359;\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits) \n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n	return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n	float a = roughness*roughness;\n	\n	float phi = 2.0 * PI * Xi.x;\n	float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n	float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n	\n	// from spherical coordinates to cartesian coordinates - halfway vector\n	vec3 H;\n	H.x = cos(phi) * sinTheta;\n	H.y = sin(phi) * sinTheta;\n	H.z = cosTheta;\n	\n	// from tangent-space H vector to world-space sample vector\n	vec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n	vec3 tangent   = normalize(cross(up, N));\n	vec3 bitangent = cross(N, tangent);\n	\n	vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n	return normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    // note that we use a different k for IBL\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n// ----------------------------------------------------------------------------\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0; \n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    \n    const uint SAMPLE_COUNT = 1024u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the\n        // preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n// ----------------------------------------------------------------------------\n\nout vec2 fragColor;\nsmooth in vec2 texCoord;\n\nvoid main() \n{\n    vec2 integratedBRDF = IntegrateBRDF(texCoord.x, texCoord.y);\n    fragColor = integratedBRDF;\n}\n";
const std::string equi_rectangular_map_frag_shader = "#version 450 core\n\nlayout(binding=0) uniform sampler2D equirectangularMap;\n\nin vec3 localPos;\nout vec4 fragColor;\nconst vec2 invAtan = vec2(0.1591, 0.3183);\n\nvec2 sampleSphere(vec3 v){\n	vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n    uv *= invAtan;\n    uv += 0.5;\n    return uv;\n}\n\nvoid main(){\n    vec2 uv = sampleSphere(normalize(localPos)); \n    vec3 color = texture(equirectangularMap, uv).rgb;\n    \n    fragColor = vec4(color, 1.0);\n}\n";
const std::string equi_rectangular_map_vert_shader = "#version 450 core\n\nuniform mat4 MVP;\n\nlayout(location=0) in vec3 position;\n\nsmooth out vec3 localPos;\n\nvoid main(){\n	localPos = position;\n	gl_Position = MVP * vec4(localPos, 1.0);\n}\n";
const std::string font_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(binding=10) uniform sampler2D glyph;\nuniform vec4 color;\nuniform vec4 backgroundColor;\nuniform bool useBackgroundColor;\n\nin vec2 texCoord;\nout vec4 fragColor;\n\nvoid main(){\n	float alpha = texture(glyph, texCoord).r;\n	fragColor = vec4(1, 1, 1, alpha) * color;\n}\n";
const std::string font_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(location=0) in vec4 coord;\n\nuniform mat4 P;\nsmooth out vec2 texCoord;\n\nvoid main(){\n	gl_Position = P * vec4(coord.xy, 0, 1);\n	texCoord = coord.zw;\n}\n";
const std::string identity_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nin VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n} vertex;\n\nout vec4 fragColor;\n\nvoid main(){\n	fragColor = vertex.color;\n}\n";
const std::string identity_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nuniform mat4 M;\nuniform mat4 V;\nuniform mat4 P;\nuniform mat4 MVP;\n\nlayout(location=0) in vec3 position;\nlayout(location=1) in vec3 normal;\nlayout(location=2) in vec3 tangent;\nlayout(location=3) in vec3 bitangent;\nlayout(location=4) in vec4 color;\nlayout(location=5) in vec2 uv;\nlayout(location=8) in mat4 xform;\n\nout VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n} vertex;\n\nlayout(xfb_buffer=0, xfb_offset=0) out vec3 capture_position;\n\nvoid main(){\n	mat4 MV = V *  xform * M;\n	mat3 NM = transpose(inverse(mat3(MV)));\n	vertex.normal = normalize(NM * normal);\n	vertex.position = (MV * vec4(position, 1)).xyz;\n	vertex.texCoord = uv;\n	vertex.color = color;\n\n	capture_position = (M * xform * vec4(position, 1.0)).xyz;\n\n	gl_Position = P * V * M * xform * vec4(position, 1);\n}\n";
const std::string irradiance_convolution_frag_shader = "#version 450 core\n\nlayout(binding = 0) uniform samplerCube environmentMap;\n\nout vec4 fragColor;\nsmooth in vec3 localPos;\nconst float PI = 3.14159265359;\nuniform int nSamples;\n\nvoid main()\n{		\n    vec3 N = normalize(localPos);\n\n    vec3 irradiance = vec3(0.0);   \n    \n    // tangent space calculation from origin point\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up            = cross(N, right);\n       \n    float sampleDelta = 0.025;\n    float nrSamples = 0.0f;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            // tangent space to world\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; \n\n            irradiance += texture(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n    \n    fragColor = vec4(irradiance, 1.0);\n}\n";
const std::string irradiance_convolution_vert_shader = "#version 450 core\n\nuniform mat4 MVP;\n\nlayout(location=0) in vec3 position;\n\nsmooth out vec3 localPos;\n\nvoid main(){\n	localPos = position;\n	gl_Position = MVP * vec4(localPos, 1.0);\n}\n";
const std::string lfp_irradiance_render_frag_shader = "#version 450 core\n\nlayout(binding=0) uniform samplerCubeArray cubeArrayMap;\n\nsmooth in vec3 texCoord;\n\nuniform int layer = 0;\nuniform bool isDistance = false;\nuniform bool isDistanceSqure = false;\n\nout vec4 fragColor;\n\nvec3 color(){\n	vec4 dir = vec4(texCoord, layer);\n	vec3 c = vec3(0);\n	if(isDistance){\n		c = texture(cubeArrayMap, dir).rrr;\n	}else if(isDistanceSqure){\n		c = texture(cubeArrayMap, dir).ggg;\n	}else{\n		c = texture(cubeArrayMap, dir).rgb;\n	}\n\n	if(isDistance || isDistanceSqure){\n		c = c/(c + 1);\n	}\n	return c;\n}\n\nvoid main(){\n	fragColor = vec4(color(), 1.0);\n}\n";
const std::string lfp_irradiance_render_vert_shader = "#version 450 core\n\nlayout(location = 0) in vec3 position;\n\nsmooth out vec3 texCoord;\n\nuniform mat4 M;\nuniform mat4 V;\nuniform mat4 P;\n\nvoid main(){\n	texCoord = position;\n	mat4 rotV = mat4(mat3(V));\n	vec4 pos = P * rotV * M * vec4(position, 1.0);\n	gl_Position = pos.xyww;\n}\n";
const std::string lfp_prefilter_frag_shader = "#version 450 core\n#pragma storeIntermediate(on)\n\nlayout(binding = 0) uniform samplerCube cubeMap;\n\nconst float PI = 3.1415926535897932384626422832795028841971;\n\nuniform int numSamples;\nuniform float lobeSize;\n\nvec3 octDecode(vec2 uv);\nvec3 hammersleySphere(int i, uint N);\n\nuniform bool irradiance = false;\n\nin smooth vec3 texCoord;\n\nlayout(location=0) out vec4 fragColor;\n\nvoid main(){\n	\n	vec3 N = normalize(texCoord);\n	vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up = cross(N, right);\n\n	vec3 total = vec3(0);\n	for(int i = 0; i < numSamples; i++){\n		vec3 p = hammersleySphere(i, numSamples);\n		vec3 sampleDirection = (p.x * right + p.y * up + p.z * N) * lobeSize;\n\n		total += texture(cubeMap, sampleDirection).rgb;\n	}\n\n	total /= float(numSamples);\n	//total = irradiance ? total * PI : total;\n\n	fragColor = vec4(total, 1.0);\n}\n\n#pragma include(\"octahedral.glsl\")\n#pragma include(\"sampling.glsl\")\n";
const std::string lfp_prefilter_geom_shader = "#version 450 core\n\nlayout(triangles) in;\nlayout(triangle_strip, max_vertices=18) out;\n\nuniform int layer;\nuniform mat4 views[6];\nuniform mat4 projection;\n\nout smooth vec3 texCoord;\n\nvoid main(){\n	for(int face = 0; face < 6; face++){\n		gl_Layer = layer * 6 + face;\n		for(int i = 0; i < gl_in.length(); i++){\n			texCoord = gl_in[i].gl_Position.xyz;\n			gl_Position = projection * views[face] * gl_in[i].gl_Position;\n			EmitVertex();\n		}\n		EndPrimitive();\n	}\n}\n";
const std::string lfp_prefilter_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\n\nlayout(location=0) in vec3 position;\n\nvoid main(){\n\n	gl_Position = vec4(position, 1.0);\n}\n";
const std::string lightMap_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(binding=0) uniform sampler2D image0;\nlayout(binding=1) uniform sampler2D image1;\n\nsmooth in vec2 interpolatedTexCoord;\nsmooth in vec2 interpolatedLightTexCoord;\n\nout vec4 fragColor;\n\nvoid main(){\n	vec4 color = texture(image0, interpolatedTexCoord);\n	vec4 light = texture(image1, interpolatedLightTexCoord);\n	fragColor = light * color;\n}\n";
const std::string lightMap_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nuniform mat4 M;\nuniform mat4 V;\nuniform mat4 P;\n\nlayout(location=0) in vec3 position;\nlayout(location=1) in vec3 normal;\nlayout(location=2) in vec3 tangent;\nlayout(location=3) in vec3 bitangent;\nlayout(location=4) in vec4 color;\nlayout(location=5) in vec2 lightUV;\nlayout(location=6) in vec2 uv;\n\nsmooth out vec2 interpolatedTexCoord;\nsmooth out vec2 interpolatedLightTexCoord;\n\nvoid main(){\n	interpolatedTexCoord = uv;\n	interpolatedLightTexCoord = lightUV;\n	gl_Position = P * V * M * vec4(position, 1);\n}\n";
const std::string mass_spring_comp_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(local_size_x = $cols, local_size_y = $rows) in;\n\nlayout(std430, binding=0) buffer CURR_POSITIONS{\n	vec3 positionsIn[];\n};\n\nlayout(std430, binding=1) buffer CURR_POSITIONS_OUT{\n	vec3 positionsOut[];\n};\n\n\nlayout(std430, binding=2) buffer PREV_POSITIONS{\n	vec3 prev_positionsIn[];\n};\n\nlayout(std430, binding=3) buffer PREV_POSITIONS_OUT{\n	vec3 prev_positionsOut[];\n};\n\nlayout(std430, binding=4) buffer COEFFICIENT_BLOCK{\n	float vd;\n	float ks[3];\n	float kd[3];\n} Coefficients;\n\n\n//float vd = -0.05f;\n//const float ks[3] = {10.5, 0.25, 0.25};\n//float kd[3] = {-0.0055, -0.00025, -0.00025};\n\nuniform vec2 patch_length;\nuniform float dt = 0.016666666666666;\nuniform vec3 gravity = vec3(0, 9.8, 0);\nuniform float m;\nuniform float r;\nuniform vec4 c;\n\nconst uvec3 CLOTH_SIZE = (gl_NumWorkGroups * gl_WorkGroupSize);\n\n\nuint flatten(ivec3 id){\n	uvec3 size = CLOTH_SIZE;\n	return id.z * size.x * size.y  + id.y * size.x + id.x;\n}\n\nconst uint TOP_LEFT_CORNER = 0;\nconst uint TOP_RIGHT_CORNER = flatten(ivec3(CLOTH_SIZE.x - 1, 0, 0));\n\n\nconst ivec2 NeighborOffsets[3][4] = {\n	{ ivec2(1, 0), ivec2(0, -1), ivec2(-1, 0), ivec2(0, 1) } // structural springs  \n	, { ivec2(1, -1), ivec2(-1, -1), ivec2(-1, 1), ivec2(1, 1) } // shear springs\n	, { ivec2(2, 0), ivec2(0, -2), ivec2(-2, 0), ivec2(0, 2) } // flex springs\n};\n\nvec3 spring_force(vec3 x, vec3 x1, vec3 v, vec3 v1, float l, float kd, float ks){\n	vec3 d = x - x1;\n	float dl = length(d);\n\n	float left = -ks * (dl - l);\n	float right = kd * dot(v - v1, d/dl);\n	\n	return ((d/dl) * (left + right));\n}\n\nvec3 external_force(vec3 velocity, float damping, float mass){\n	return gravity * mass + velocity * damping;\n}\n\nvec3 integrate(vec3 p, vec3 p1, vec3 a, float t){\n	return 2 * p - p1  + a * t * t;\n}\n\nbool exists(ivec3 pos){\n	uvec2 size = (gl_NumWorkGroups * gl_WorkGroupSize).xy;\n	return (pos.x >= 0 && pos.x < size.x) && (pos.y >= 0 && pos.y < size.y);\n}\n\nvoid main(){\n\n	uint loc = flatten(ivec3(gl_GlobalInvocationID));\n	vec3 pos = positionsIn[loc];\n	vec3 prev_pos = prev_positionsIn[loc];\n	vec3 velocity = (pos - prev_pos)/dt;\n	float mass = m;\n\n	if(loc == TOP_LEFT_CORNER || loc == TOP_RIGHT_CORNER) mass = 0; \n\n	vec3 force = external_force(velocity, Coefficients.vd, mass);\n	\n	for(int i = 0; i < 3; i++){\n		for(int j = 0; j < 4; j++){\n			ivec3 neighbor = ivec3(gl_GlobalInvocationID) + ivec3(NeighborOffsets[i][j], 0);\n			if(!exists(neighbor)) continue;\n			uint loc = flatten(neighbor);\n			vec3 pos1 = positionsIn[loc];\n			vec3 prev_pos1 = prev_positionsIn[loc];\n			vec3 velocity1 = (pos1 - prev_pos1)/dt;\n\n			float resting_length = length(NeighborOffsets[i][j] * patch_length);\n\n			force += spring_force(pos, pos1, velocity, velocity1, resting_length, Coefficients.kd[i], Coefficients.ks[i]);\n		}\n	}\n\n	vec3 acceleration = vec3(0);\n	if(mass != 0) acceleration = force/mass;\n\n	vec3 curr_pos = pos;\n	vec3 next_pos = integrate(pos, prev_pos, acceleration, dt);\n\n\n	next_pos.y = max(0, next_pos.y);\n\n	vec3 delta = next_pos - c.xyz;\n	float pd = dot(delta, delta);\n\n	if(pd < r * r){\n		vec3 dir = normalize(delta);\n		next_pos = c.xyz + dir * r;\n	}\n\n\n	prev_positionsIn[loc] = curr_pos;\n	positionsIn[loc] = next_pos;\n}\n";
const std::string noise_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\n#define PI 3.14159265\n\nlayout(binding=0) uniform sampler2D noise;\n\nuniform vec4 sky = vec4(0.3, 0.3, 0.9, 1.0);\nuniform vec4 cloud = vec4(1.0);\n\nin VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n} vertex;\n\nout vec4 color;\n\nvoid main(){\n	vec4 oct = texture(noise, vertex.texCoord);\n	float sum =  ( oct.r + oct.g + oct.b + oct.a - 1)/2;\n	float t = (cos(sum * PI) + 1.0)/2.0;\n	vec4 c = mix(sky, cloud, t);\n	color = vec4(c.rgb, 1.0);\n}\n";
const std::string octahedral_frag_shader = "#version 450 core\n\n#pragma storeIntermediate(on)\n\nconst float PI = 3.1415926535897932384626422832795028841971;\nconst float TWO_PI = 6.2831853071795864769252867665590057683943;\n\nlayout(binding = 0 ) uniform samplerCube radianceMap;\nlayout(binding = 1 ) uniform samplerCube normalMap;\nlayout(binding = 2) uniform samplerCube distanceMap;\n\nsmooth in vec2 texCoord;\n//smooth in vec4 o_color;\n\nlayout(location = 0) out vec4 fragColor;\nlayout(location = 1) out vec4 o_normal;\nlayout(location = 2) out vec4 o_distance;\n\nvec3 octDecode(in vec2 v);\n\nvec3 direction_from_spherical(vec2 uv)\n{\n	float phi = uv.x * TWO_PI;\n	float theta = uv.y * PI;\n\n	return vec3(\n		sin(phi) * sin(theta) * -1.0,\n		cos(theta) * -1.0,\n		cos(phi) * sin(theta) * -1.0\n	);\n}\n\nvoid main(){\n	//vec3 direction = direction_from_spherical(texCoord);\n	vec3 direction = octDecode(texCoord * vec2(2.0) - vec2(1.0));\n\n	fragColor = texture(radianceMap, direction);\n//	fragColor = o_color;\n	o_normal = texture(normalMap, direction);\n	o_distance = texture(distanceMap, direction);\n\n}\n\n#pragma include(\"octahedral.glsl\")\n";
const std::string octahedral_geom_shader = "#version 450 core\n\nlayout(triangles) in;\nlayout(triangle_strip, max_vertices=18) out;\n\n\n\nin ncl_PerVertex{\n	smooth vec2 texCoord;\n} ncl_in[3];\n\nsmooth out vec2 texCoord;\nsmooth out vec4 o_color;\n\nuniform int layer;\nuniform vec4 color;\n\nvoid main(){\n	for(int i = 0; i < 3; i++){\n		gl_Layer = layer;\n		vec4 worldPos = gl_in[i].gl_Position;\n\n		texCoord = ncl_in[i].texCoord;\n		o_color = color;\n\n		gl_Position = gl_in[i].gl_Position;\n		EmitVertex();\n	}\n\n	EndPrimitive();\n}\n";
const std::string octahedral_vert_shader = "#version 450 core \n\n\nlayout(location = 0) in vec3 position;\nlayout(location = 5) in vec2 uv;\nlayout(location=8) in mat4 xform;\n\n//out ncl_PerVertex{\n	out smooth vec2 texCoord;\n//};\n\nvoid main(){\n	texCoord = uv;\n	gl_Position =  xform * vec4(position, 1);\n}\n";
const std::string octahedral_low_res_distance_frag_shader = "#version 450 core\n\n#pragma storeIntermediate(on)\n\nconst float PI = 3.1415926535897932384626422832795028841971;\nconst float TWO_PI = 6.2831853071795864769252867665590057683943;\n\nlayout(binding = 0) uniform samplerCube distanceMap;\n\nsmooth in vec2 texCoord;\n\nlayout(location = 0) out vec4 fragColor;\n\nvec3 octDecode(in vec2 v);\n\n\nvoid main(){\n	vec3 direction = octDecode(texCoord * vec2(2.0) - vec2(1.0));\n	fragColor = texture(distanceMap, direction);\n}\n\n#pragma include(\"octahedral.glsl\")\n";
const std::string octahedral_render_frag_shader = "#version 450 core \n\nlayout(binding = 0) uniform sampler2DArray image;\n\n\nuniform int numLayers;\nuniform bool isDistance = false;\nuniform bool isDistanceSqrd = false;\n\nin ncl_PerVertex{\n	smooth vec2 texCoord;\n	flat int layer;\n};\n\nout vec4 fragColor;\n\nvec3 getColor(int layer){\n	if(isDistance){\n		return texture(image, vec3(texCoord, layer)).rrr;\n	}else if(isDistanceSqrd){\n		return texture(image, vec3(texCoord, layer)).ggg;\n	}else{\n		return texture(image, vec3(texCoord, layer)).rgb;\n	}\n}\n\nvoid main(){\n	float actual_layer = max(0, min(numLayers - 1 , floor(layer + 0.5)));\n	vec3 color = getColor(int(layer));\n	color = isDistance || isDistanceSqrd ? color / (color + vec3(1.0)) : color;\n	fragColor = vec4(color, 1.0);\n}\n";
const std::string octahedral_render_geom_shader = "#version 450 core\n\nlayout(triangles, invocations = 2) in;\nlayout(triangle_strip, max_vertices=128) out;\n\n\nin ncl_PerVertex{\n	smooth vec2 texCoord;\n} ncl_in[3];\n\nout ncl_PerVertex{\n	smooth vec2 texCoord;\n	flat int layer;\n};\n\nuniform int numLayers;\nuniform int columns = 8;\nuniform float aspectRatio = 1;\nuniform bool renderAll = true;\nuniform int uLayer;\n\nmat4 translate4x4(vec3 t) {\n    return mat4(1,0,0,0,\n                  0,1,0,0,\n                  0,0,1,0,\n                  t,1);\n}\n\nmat4 scale4x4(vec3 s){\n    return mat4(s.x,0,0,0,\n                  0,s.y,0,0,\n                  0,0,s.z,0,\n                  0, 0, 0,1);\n}\n\nconst int MAX_TRIANGLES_PER_INSTANCE = 42;\n\nvoid main(){\n    int cols = columns;\n    while(numLayers < cols) cols /= 2;\n	float w = 1.0/cols;\n	float h = w/aspectRatio;\n	mat4 s = scale4x4(vec3(w, h, 1));\n\n    if(renderAll){\n        int level = gl_InvocationID * MAX_TRIANGLES_PER_INSTANCE;\n        for(int level = gl_InvocationID * 42; level < numLayers; level++){\n            gl_Layer = level;\n            for(int i = 0; i < gl_in.length(); i++){\n                layer = level;\n                texCoord = ncl_in[i].texCoord;\n                float x = w-1 + (level%cols) * w * 2;\n                float y = 1 - h - ((level/cols) * (h * 2));\n                mat4 model = translate4x4(vec3(x, y, 0)) *  s;\n               // mat4 model = mat4(1);\n                gl_Position = model * gl_in[i].gl_Position;\n                EmitVertex();\n            }\n            EndPrimitive();\n        }\n    }else{\n        for(int i = 0; i < gl_in.length(); i++){\n            layer = uLayer;\n            texCoord = ncl_in[i].texCoord;\n            gl_Position = gl_in[i].gl_Position;\n            EmitVertex();\n        }\n        EndPrimitive();\n    }\n\n}\n";
const std::string pass_through_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nsmooth in vec4 fColor;\nout vec4 fragColor;\n\nvoid main(){\n	fragColor = vec4(1);\n}\n";
const std::string pass_through_geom_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(triangles) in;\nlayout(triangle_strip, max_vertices = 3) out;\n\nvoid main(){\n	for(int i = 0; i < gl_in.length(); i++){\n		gl_Position = gl_in[i].gl_Position;\n		EmitVertex();\n	}\n	EmitPrimitive();\n}\n";
const std::string pass_through_tcs_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout (vertices = 16) out;\n\nvoid main(){\n	\n	gl_TessLevelOuter[0] = 4;\n	gl_TessLevelOuter[1] = 4;\n	gl_TessLevelOuter[2] = 4;\n	gl_TessLevelOuter[3] = 4;\n\n	gl_TessLevelInner[0] = 10;\n	gl_TessLevelInner[1] = 10;\n\n	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;\n}\n";
const std::string pass_through_tes_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout (quads, equal_spacing, ccw) in;\n\nvoid main(){\n	gl_Position = gl_in[gl_InvocationID].gl_Position;\n}\n";
const std::string pass_through_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nuniform mat4 M;\nuniform mat4 V;\nuniform mat4 P;\n\nlayout(location=0) in vec3 position;\nlayout(location=5) in vec4 color;\nsmooth out vec4 fColor;\n\nvoid main(){\n	fColor = color;\n	gl_Position = P * V * M * vec4(position, 1);\n}\n";
const std::string per_fragment_lighing_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nconst int MAX_LIGHT_SOURCES = 10;\nconst int MAX_TEXTURES = 8;\n\n\nlayout(binding = 0) uniform sampler2D image0;\nlayout(binding = 1) uniform sampler2D image1;   // normalMap if using object  space\nlayout(binding=2) uniform sampler2D image2;\nlayout(binding=3) uniform sampler2D image3;\nlayout(binding=4) uniform sampler2D image4;\nlayout(binding=5) uniform sampler2D image5;\nlayout(binding=6) uniform sampler2D image6;\nlayout(binding=7) uniform sampler2D image7;\n\nstruct LightSource{\n	vec4 position;\n	vec4 ambient;\n	vec4 diffuse;\n	vec4 specular;\n	vec4 spotDirection;\n	float spotAngle;\n	float spotExponent;\n	float kc;\n	float ki;\n	float kq;\n	bool transform;\n	bool on;\n};\n\nstruct Material{\n	vec4 emission;\n	vec4 ambient;\n	vec4 diffuse;\n	vec4 specular;\n	float shininess;\n	int diffuseMat;\n	int specularMat;\n	int ambientMat;\n	int bumpMap;\n};\n\nstruct LineInfo{\n	float width;\n	vec4 color;\n};\n\nstruct ToonShader{\n	int levels;\n	float scaleFactor;\n};\n\nstruct LightModel {\n	bool localViewer;\n	bool twoSided;\n	bool useObjectSpace;\n	bool celShading;\n	vec4 globalAmbience;\n	bool colorMaterial;\n};\n\nuniform mat4 MV;\nuniform mat4 V;\nuniform LightSource light[MAX_LIGHT_SOURCES];\nuniform Material material[2];\nuniform LineInfo line;\nuniform bool wireframe;\nuniform LightModel lightModel;\nuniform bool activeTextures[MAX_TEXTURES];\nuniform int blendTex[MAX_TEXTURES - 1];\nuniform int numLights = 1;\n\nToonShader toonShader;\n\nin VERTEX{\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n	smooth vec3 eyes;\n	smooth vec4 lightDirection[MAX_LIGHT_SOURCES];\n} vertex;\nnoperspective in vec3 edgeDistance;\n\nout vec4 fragColor;\n\nvec4 getAmbience(Material m){\n	return lightModel.colorMaterial ? vertex.color : m.ambient;\n}\n\nvec4 getDiffuse(Material m){\n	return lightModel.colorMaterial ? vertex.color : m.diffuse;\n}\n\nfloat daf(float dist, LightSource light){\n	if(light.position.w == 0) return 1;\n	return 1.0 / (light.kc + light.ki * dist + light.kq * dist * dist);\n}\n\nfloat saf(LightSource light, vec3 lightDirection){\n	if(light.position.w == 0) return 1;\n	vec3 l = normalize(lightDirection);\n	//vec3 d =   normalize(mat3(V) * light.spotDirection.xyz);\n	vec3 d =   normalize(light.spotDirection.xyz);\n	float h = light.spotExponent;\n	\n	if(light.spotAngle >= 180) 	return 1.0;\n	\n	float _LdotD = dot(-l, d);\n	float cos_spotAngle = cos(radians(light.spotAngle));\n	\n	if(_LdotD < cos_spotAngle) return 0.0;\n	\n	return pow(_LdotD, h); \n}\n\nfloat getLineMixColor(){\n	float d = min( min(edgeDistance.x, edgeDistance.y), edgeDistance.z);\n	return smoothstep(line.width - 1, line.width + 1, d);\n}\n\nvec4 apply(LightSource light, vec4 direction, Material m){\n	if(!light.on) return vec4(0);\n	toonShader.levels = 3;\n	toonShader.scaleFactor = 1.0 / toonShader.levels;\n	vec3 n = gl_FrontFacing ? normalize(vertex.normal) : normalize(-vertex.normal);\n	n = lightModel.useObjectSpace ? (2.0 * texture(image1, vertex.texCoord) - 1.0).xyz : n;\n//	n = (2.0 * texture(image1, vertex.texCoord) - 1.0).xyz;\n	vec3 l = normalize(direction.xyz);\n	float f = m.shininess;\n		\n	float _daf = daf(length(l), light);\n\n	float _saf = saf(light, l);\n	\n	vec4 ambient = light.ambient * m.ambient;\n	\n	vec4 diffuse =  lightModel.celShading ? floor(max(dot(l, n), 0) * toonShader.levels) * toonShader.scaleFactor * light.diffuse *  getDiffuse(m)\n							: max(dot(l, n), 0)  * light.diffuse * m.diffuse;\n	\n	vec3 e = normalize(vertex.eyes);\n	vec3 s = normalize(l + e);	// half way vector between light direction and eyes\n	vec4 specular = pow(max(dot(s, n), 0), f) * light.specular * m.specular;\n\n	return  _daf * _saf * (ambient + diffuse + specular); \n}\n\nvec4 phongLightModel(){\n	Material m = !lightModel.twoSided ?  material[0] : gl_FrontFacing ? material[0] : material[1];\n	vec4 color = m.emission + lightModel.globalAmbience * getAmbience(m);\n\n	for(int i = 0; i < numLights; i++ ) \n		color += apply(light[i], vertex.lightDirection[i], m);\n\n	return color;\n}\n\nvec4 texColor(){\n	vec4 colors[] = {\n		texture(image0, vertex.texCoord), texture(image1, vertex.texCoord)\n		, texture(image2, vertex.texCoord), texture(image3, vertex.texCoord)\n		, texture(image4, vertex.texCoord), texture(image5, vertex.texCoord)\n		, texture(image6, vertex.texCoord), texture(image7, vertex.texCoord)\n	};	// TODO use texCoord array\n\n	vec4 color = vec4(1);\n	int next = 0;\n	for(; next < MAX_TEXTURES; next++){\n		if(activeTextures[next]){\n			color = colors[next];\n			break;\n		}\n	}\n//	for(int i = 0; i < blendTex.length(); i++){\n//		int blendId = blendTex[i];\n//		if(blendId != 0){\n//			vec4 blendColor = colors[blendId];\n//			color = mix(color, blendColor, blendColor.a);\n//		}\n//	}\n	return color;\n}\n\nvoid main(){\n	fragColor = phongLightModel() * texColor();\n	//fragColor = wireframe ? mix(line.color, fragColor, getLineMixColor()) : fragColor;\n//	fragColor = texture(image0, vertex.texCoord);\n}\n";
const std::string per_fragment_lighing_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nconst int MAX_LIGHT_SOURCES = 10;\n\nlayout(location=0) in vec3 position;\nlayout(location=1) in vec3 normal;\nlayout(location=2) in vec3 tangent;\nlayout(location=3) in vec3 bitangent;\nlayout(location=4) in vec4 color;\nlayout(location=5) in vec2 uv;\nlayout(location=6) in vec2 uv1;\n\nuniform struct LightSource{\n	vec4 position;\n	vec4 ambient;\n	vec4 diffuse;\n	vec4 specular;\n	vec4 spotDirection;\n	float spotAngle;\n	float spotExponent;\n	float kc;\n	float ki;\n	float kq;\n	bool transform;\n	bool on;\n} light[MAX_LIGHT_SOURCES];\n\nstruct LightModel {\n	bool localViewer;\n	bool twoSided;\n	bool useObjectSpace;\n	bool celShading;\n	vec4 globalAmbience;\n	bool colorMaterial;\n};\n\n\nout VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n	smooth vec3 eyes;\n	smooth vec4 lightDirection[MAX_LIGHT_SOURCES];\n} vertex;\n\nnoperspective out vec3 edgeDistance;\nuniform mat4 V;\nuniform mat4 M;\nuniform mat4 P;\nuniform LightModel lightModel;\nuniform mat3 normalMatrix;\nuniform bool useObjectSpace;\nuniform bool capture;\nuniform bool uvMappedToSize;\nuniform int numLights = 1;\n\nlayout(xfb_buffer=0, xfb_offset=0) out vec3 capture_position;\n\nmat3 OLM;\nmat4 MV;\nmat4 MVP;\nmat3 NM;\n\nvec4 getLightDirection(vec4 pos, in LightSource light){\n	vec4 direction = vec4(0);\n	if(light.position.w == 0){	// directional light\n\n		direction = light.position;\n	}\n	else{	// positional light\n		vec4 lightPos = (light.position/light.position.w);\n		direction = (V*light.position) - pos;\n	}\n	return normalize(vec4( OLM * direction.xyz, 1.0));\n}\n\nvoid main(){\n	vec3 n = normalize(normalMatrix * normal);\n	vec3 t = normalize(normalMatrix * tangent);\n	vec3 b = normalize(normalMatrix * bitangent);\n\n	MV = V * M;\n	MVP = P * MV;\n\n	vertex.normal =  n;\n	vec4 pos = MV * vec4(position, 1);\n	vertex.position = pos.xyz;\n\n	capture_position = (M * vec4(position, 1.0)).xyz;\n	\n	OLM = !lightModel.useObjectSpace ? mat3(1) : mat3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);\n\n	for(int i = 0; i < numLights; i++){\n		vertex.lightDirection[i] = getLightDirection(pos, light[i]);\n	}\n\n	vertex.eyes =  OLM * (lightModel.localViewer ? normalize(-pos.xyz) : vec3(0, 0, 1));\n\n	vertex.texCoord = uvMappedToSize ? uv1 : uv;\n	vertex.color = color;\n	gl_Position = MVP * vec4(position, 1);\n}\n";
const std::string per_fragment_lighting2_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n#pragma storeIntermediate(on)\n#pragma include(\"lighting.frag.glsl\")\n#pragma include(\"composite_diffuse.glsl\")\n\nout vec4 fragColor;\n\nuniform bool gammaCorrect;\n\nconst float gamma = 2.2;\n\nvoid main(){\n	vec4 color = phongLightModel(mat4(1));\n	fragColor = gammaCorrect ? vec4(pow(color.rgb, vec3(1/gamma)), color.a) : color;	\n}\n";
const std::string per_fragment_lighting2_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n#pragma storeIntermediate(on)\n#pragma include(\"lighting.vert.glsl\")\n\nlayout(location=0) in vec3 position;\nlayout(location=1) in vec3 normal;\nlayout(location=2) in vec3 tangent;\nlayout(location=3) in vec3 bitangent;\nlayout(location=4) in vec4 color;\nlayout(location=5) in vec2 uv;\nlayout(location=6) in vec2 uv1;\nlayout(location=8) in mat4 xform;\n\nuniform mat4 M;\nuniform mat4 V;\nuniform mat4 P;\nuniform mat4 MV;\nuniform mat4 MVP;\nuniform bool uvMappedToSize;\nuniform bool useXform;\n\n\nvoid main(){\n	\n	vec4 pos = vec4(position, 1);\n	pos = useXform ? xform * pos : pos;\n	vec3 n = useXform ? mat3(xform) * normal : normal;\n	vec3 t = useXform ? mat3(xform) * tangent : tangent;\n	vec3 bi = useXform ? mat3(xform) * bitangent : bitangent;\n	applyLight(MV, V, pos.xyz, n, t, bi);\n	vertex_out.texCoord = uvMappedToSize ? uv1 : uv;\n	vertex_out.color = color;\n	gl_Position = MVP * pos;\n}\n";
const std::string phong_lighting_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nstruct LightSource{\n	vec4 position;\n	vec4 ambient;\n	vec4 diffuse;\n	vec4 specular;\n	vec4 spotDirection;\n	float spotAngle;\n	float spotExponent;\n	float kc;\n	float ki;\n	float kq;\n	bool transform;\n};\n\nstruct Material{\n	vec4 emission;\n	vec4 ambient;\n	vec4 diffuse;\n	vec4 specular;\n	float shininess;\n};\n\nlayout(location=0) in vec3 vVertex;		//per-vertex position\nlayout(location=1) in vec3 vNormal;		//per-vertex normal\n \n//uniforms  \nuniform mat4 MVP;				//combined modelview projection matrix\nuniform mat4 MV;				//modelview matrix\nuniform mat3 normalMatrix;					//normal matrix\nuniform LightSource light0;\nuniform Material material;\n\n//shader outputs to the fragment shader\nsmooth out vec4 color;    //final diffuse colour to the fragment shader\n\n//shader constant\nconst vec3 vEyeSpaceCameraPosition = vec3(0,0,0); //eye is at vec3(0,0,0) in eye space\n\nvoid main()\n{ 	\n\n	vec3 light_position = light0.position.xyz;\n	vec3 diffuse_color = material.diffuse.xyz;\n	vec3 specular_color = material.specular.xyz;\n	float shininess = material.shininess;\n	mat3 N = normalMatrix;\n\n	//multiply the object space light position with the modelview matrix \n	//to get the eye space light position\n	vec4 vEyeSpaceLightPosition = MV*vec4(light_position,1);\n\n	//multiply the object space vertex position with the modelview matrix \n	//to get the eye space vertex position\n	vec4 vEyeSpacePosition = MV*vec4(vVertex,1); \n\n	//multiply the object space normal with the normal matrix \n	//to get the eye space normal\n	vec3 vEyeSpaceNormal   = normalize(N*vNormal);\n\n	//get the light vector\n	vec3 L = normalize(vEyeSpaceLightPosition.xyz-vEyeSpacePosition.xyz);\n	//get the view vector\n	vec3 V = normalize(vEyeSpaceCameraPosition.xyz-vEyeSpacePosition.xyz);\n	//get the half way vector between light and view vectors\n	vec3 H = normalize(L+V);\n\n	//calculate the diffuse and specular components\n	float diffuse = max(0, dot(vEyeSpaceNormal, L));\n	float specular = max(0, pow(dot(vEyeSpaceNormal, H), shininess));\n\n	//calculate the final colour by adding the diffuse and specular components\n	color = diffuse*vec4(diffuse_color,1) + specular*vec4(specular_color, 1);\n\n	//multiply the combiend modelview projection matrix with the object space vertex\n	//position to get the clip space position\n    gl_Position = MVP*vec4(vVertex,1); \n}\n \n";
const std::string phong_lighting2_vert_shader = "\n#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nstruct LightSource{\n	vec4 position;\n	vec4 ambient;\n	vec4 diffuse;\n	vec4 specular;\n	vec4 spotDirection;\n	float spotAngle;\n	float spotExponent;\n	float kc;\n	float ki;\n	float kq;\n	bool transform;\n};\n\nstruct Material{\n	vec4 emission;\n	vec4 ambient;\n	vec4 diffuse;\n	vec4 specular;\n	float shininess;\n};\n\nuniform mat4 MV;\nuniform mat4 MVP;\nuniform mat3 normalMatrix;\n\nuniform LightSource light0;\nuniform Material material;\nuniform vec4 globalAmbience;\nuniform bool localViewer;\nuniform bool eyesAtCamera;\n\nlayout(location=0) in vec3 position;\nlayout(location=1) in vec3 normal;\nlayout(location=2) in vec3 tangent;\nlayout(location=3) in vec3 bitangent;\nlayout(location=4) in vec4 color;\nlayout(location=5) in vec2 uv;\n\nout VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n} vertex;\n\nvec3 lightDirection(vec4 pos, LightSource light);\n\nfloat daf(float dist, LightSource light);\n\nfloat saf(LightSource light, vec3 lightDirection);\n\n\nvoid main(){\n	Material m = material;\n	vec3 n = normalize(normalMatrix * normal);\n	vec4 pos = (MV * vec4(position, 1));\n//	vec3 l = lightDirection(pos, light0);\n	vec3 l = normalize((MV*light0.position).xyz - pos.xyz);\n	float f = m.shininess;\n	\n	vec4 gobAmbient = m.emission + globalAmbience * m.ambient;\n	\n	float _daf = daf(length(l), light0);\n	float _saf = saf(light0, l);\n	\n	vec4 ambient = light0.ambient * m.ambient;\n	\n	vec4 diffuse = max(dot(l, n), 0) * light0.diffuse * m.diffuse;\n	\n	vec3 e = normalize(-pos.xyz);\n	vec3 s = normalize(l + e);	// half way vector between light direction and eyes\n	vec4 specular = pow(max(dot(s, n), 0), f) * light0.specular * m.specular;\n\n\n	vertex.color = gobAmbient + _daf * _saf * ((ambient + diffuse) + specular); \n\n	gl_Position = MVP * vec4(position, 1);\n}\n\n\nfloat daf(float dist, LightSource light){\n	return 1.0 / (light.kc + light.ki * dist + light.kq * dist * dist);\n}\n\nfloat saf(LightSource light, vec3 lightDirection){\n	vec3 l = normalize(lightDirection);\n	vec3 d = normalize(light.spotDirection.xyz);\n	float h = light.spotExponent;\n	\n	if(light.spotAngle >= 180) 	return 1.0;\n	\n	float _LdotD = dot(-l, d);\n	float cos_spotAngle = cos(radians(light.spotAngle));\n	\n	if(_LdotD < cos_spotAngle) return 0.0;\n	\n	return pow(_LdotD, h); \n}\n";
const std::string point_shadow_map_frag_shader = "#version 450 core \n\nuniform vec3 lightPos;\nuniform float nearPlane;\nuniform float farPlane;\n\nin vec4 fragPos;\n\nvoid main(){\n	float lightDistance = length(fragPos.xyz - lightPos);\n\n	lightDistance = lightDistance /farPlane;	// map to [0:1]\n\n	gl_FragDepth = lightDistance;\n}\n";
const std::string point_shadow_map_geom_shader = "#version 450 core\n\nlayout(triangles) in;\nlayout(triangle_strip, max_vertices=18) out;\n\n\nuniform mat4 projection;\nuniform mat4 view[6];\n\nout vec4 fragPos;\n\nvoid main(){\n	for(int face = 0; face < 6; face++){\n		gl_Layer = face;\n		for(int i = 0; i < 3; i++){\n			fragPos = gl_in[i].gl_Position;\n			gl_Position = projection * view[face] * fragPos;\n			EmitVertex();\n		}\n		EndPrimitive();\n	}\n}\n";
const std::string point_shadow_map_vert_shader = "#version 450 core \n\nlayout(location = 0) in vec3 position;\nlayout(location=8) in mat4 xform;\n\nuniform mat4 M;\n\nvoid main(){\n	gl_Position = M * xform * vec4(position, 1);\n}\n";
const std::string point_shadow_map_render_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(binding=0) uniform samplerCube shadowMap;\nsmooth in vec3 texCoord;\nout vec4 fragColor;\n\nvoid main(){\n	float depth = texture(shadowMap, texCoord).r;\n\n	fragColor = vec4(vec3(depth), 1);\n}\n";
const std::string point_shadow_map_render_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\n\nlayout(location=0) in vec3 position;\nsmooth out vec3 texCoord;\n\nuniform mat4 M;\nuniform mat4 V;\nuniform mat4 P;\n\nvoid main(){\n	texCoord = position;\n	mat4 rotV = mat4(mat3(V));\n	vec4 pos = P * rotV * M * vec4(position, 1.0);\n	gl_Position = pos.xyww;\n}\n";
const std::string probe_render_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(binding=0) uniform samplerCube probeMap;\n\nconst float MAX_REFLECTION_LOD = 4.0;\n\nsmooth in vec3 texCoord;\nout vec4 fragColor;\n\nuniform float roughness;\nuniform bool useRoughness = false;\n\nvoid main(){\n	vec3 color;\n\n	if(useRoughness){\n		color = textureLod(probeMap, texCoord, roughness * MAX_REFLECTION_LOD).rgb;\n	}else{\n		color = texture(probeMap, texCoord).rgb;\n	}\n\n	fragColor = vec4(color, 1.0);\n}\n";
const std::string probe_render_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\n\nlayout(location=0) in vec3 position;\nsmooth out vec3 texCoord;\n\nuniform mat4 M;\nuniform mat4 V;\nuniform mat4 P;\nuniform vec3 probe_loc;\n\nvoid main(){\n	texCoord = position;\n	vec4 worldPos = M * vec4(position, 1.0);\n	mat4 rotV = mat4(mat3(V));\n	vec4 pos = P * rotV * worldPos;\n	gl_Position = pos;\n}\n";
const std::string quad_tes_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout (quads, equal_spacing, ccw) in;\n\nuniform mat4 MVP;\n\nout VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n} vertex;\n\nsmooth in vec4 vcolor[];\n\nvec3 calculateNormal(){\n	vec3 p0 = gl_in[0].gl_Position.xyz;\n	vec3 p1 = gl_in[2].gl_Position.xyz;\n	vec3 p2 = gl_in[1].gl_Position.xyz;\n\n	vec3 a = p0 - p1;\n	vec3 b = p2 - p1;\n	\n	return cross(a, b); \n}\n\nvoid main(){\n	float u = gl_TessCoord.x;\n	float v = gl_TessCoord.y;\n	float i_u = 1 - u;\n	float i_v = 1 - v;\n\n	vec4 p0 = gl_in[0].gl_Position;\n	vec4 p1 = gl_in[1].gl_Position;\n	vec4 p2 = gl_in[2].gl_Position;\n	vec4 p3 = gl_in[3].gl_Position;\n\n	vec4 p = p0 * i_u * i_v + \n			 p1 * u * i_v + \n			 p3 * v * i_u +\n			 p2 * u * v;\n\n	vec3 pn = calculateNormal();\n\n	vertex.normal = normalize(pn + p.xyz);\n\n	vertex.texCoord = gl_TessCoord.xy;\n	vertex.color = vcolor[0];\n	gl_Position = MVP * p;\n}\n";
const std::string quad_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(location=0) in vec3 position;\nlayout(location=4) in vec4 color;\n\n\nlayout(binding=0) uniform samplerBuffer faces_tbo;\n\nsmooth out vec4 vcolor;\n\nmat4 model(){\n	return mat4(\n		texelFetch(faces_tbo, gl_InstanceID * 4),\n		texelFetch(faces_tbo, gl_InstanceID * 4 + 1),\n		texelFetch(faces_tbo, gl_InstanceID * 4 + 2),\n		texelFetch(faces_tbo, gl_InstanceID * 4 + 3)\n	);\n	return mat4(1);\n}\n\n\nvoid main(){\n	vcolor = color;\n	gl_Position = model() * vec4(position, 1);\n}\n";
const std::string scene_capture_geom_shader = "#version 450 core\n\nlayout(triangles) in;\nlayout(triangle_strip, max_vertices=18) out;\n\n\nuniform mat4 projection;\nuniform mat4 views[6];\nuniform mat4 lightSpaceView;\n\nin VERTEX{\n	smooth vec3 position;\n	smooth vec4 lightSpacePos;\n	smooth vec4 color;\n	smooth vec3 normal;\n	smooth vec3 tangent;\n    smooth vec3 bitangent;\n	smooth vec2 uv;\n} vert_in[];\n\nout VERTEX{\n	smooth vec3 position;\n	smooth vec4 lightSpacePos;\n	smooth vec4 color;\n	smooth vec3 normal;\n	smooth vec3 tangent;\n    smooth vec3 bitangent;\n	smooth vec2 uv;\n} vert_out;\n\nvoid main(){\n	for(int face = 0; face < 6; face++){\n		gl_Layer = face;\n		for(int i = 0; i < 3; i++){\n			vec4 worldPos = gl_in[i].gl_Position;\n\n			vert_out.position = worldPos.xyz;\n			vert_out.normal = vert_in[i].normal;\n			vert_out.tangent = vert_in[i].tangent;\n			vert_out.bitangent = vert_in[i].bitangent;\n			vert_out.color = vert_in[i].color;\n			vert_out.uv = vert_in[i].uv;\n			vert_out.lightSpacePos = lightSpaceView * worldPos;\n\n			gl_Position = projection * views[face] * worldPos;\n			EmitVertex();\n		}\n		EndPrimitive();\n	}\n}\n";
const std::string scene_capture_vert_shader = "#version 450 core \n\nlayout(location=0) in vec3 position;\nlayout(location=1) in vec3 normal;\nlayout(location=2) in vec3 tangent;\nlayout(location=3) in vec3 bitangent;\nlayout(location=4) in vec4 color;\nlayout(location=5) in vec2 uv;\nlayout(location=8) in mat4 xform;\n\nout VERTEX{\n	smooth vec3 position;\n	smooth vec4 lightSpacePos;\n	smooth vec4 color;\n	smooth vec3 normal;\n	smooth vec3 tangent;\n    smooth vec3 bitangent;\n	smooth vec2 uv;\n} vert_out;\n\nuniform mat4 M;\n\nvoid main(){\n	mat3 nform = transpose(inverse(mat3(M * xform)));\n\n	vert_out.position = (M * xform * vec4(position, 1)).xyz;\n	vert_out.color = color;\n	vert_out.normal = nform * normal;\n	vert_out.tangent = nform * tangent;\n	vert_out.bitangent = nform * bitangent;\n	vert_out.uv = uv;\n	\n	gl_Position = vec4(vert_out.position, 1.0);\n}\n";
const std::string scene_capture_phong_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\n#pragma include(\"constants.glsl\")\n\n\nlayout(binding = 0) uniform sampler2D ambientMap;\nlayout(binding = 1) uniform sampler2D diffuseMap;\nlayout(binding = 2) uniform sampler2D specularMap;\nlayout(binding = 3) uniform sampler2D normalMap;\n\n//#pragma include(\"lightFieldProbeModel.glsl\")\n\nin VERTEX{\n	smooth vec3 position;\n	smooth vec4 lightSpacePos;\n	smooth vec4 color;\n	smooth vec3 normal;\n	smooth vec3 tangent;\n	smooth vec3 bitangent;\n	smooth vec2 uv;\n} vert_in;\n\nuniform vec3 camPos;\nuniform vec3 lightPos;\nuniform float shininess = 5.0;\nuniform vec3 emission = vec3(0.0);\n\nlayout(location = 0) out vec4 fragColor;\n\nconst vec3 globalAmbience = vec3(0.3);\nconst vec3 lightColor = vec3(0.3);\nvec3 worldPos = vert_in.position;\nvec2 uv = vert_in.uv;\nvec4 posInLight = vert_in.lightSpacePos;\n\nvec3 getNormal() {\n	vec3 n = normalize(vert_in.normal);\n	vec3 t = normalize(vert_in.tangent);\n	vec3 b = normalize(vert_in.bitangent);\n\n	mat3 olm_inv = inverse(mat3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z));\n	vec3 tNormal = 2.0 * texture(normalMap, vert_in.uv).xyz - 1.0;\n	vec3 normal = olm_inv * tNormal;\n	return gl_FrontFacing ? normal : -normal;\n}\n\nvec3 getNormal0() {\n	vec3 Q1 = dFdx(worldPos);\n	vec3 Q2 = dFdy(worldPos);\n	vec2 st1 = dFdx(uv);\n	vec2 st2 = dFdy(uv);\n\n	vec3 N = normalize(vert_in.normal);\n	vec3 T = normalize(Q1 * st2.t - Q2 * st1.t);\n	vec3 B = -normalize(cross(N, T));\n	mat3 TBN = mat3(T, B, N);\n\n	vec3 tNormal = 2.0 * texture(normalMap, vert_in.uv).xyz - 1.0;\n	//return normalize(TBN * tNormal);\n	return gl_FrontFacing ? N : -N;\n	//return N;\n}\n\nfloat ShadowCalculation(vec3 worldPos, vec4 posInLight, vec3 lightPos, vec3 camPos, float NdotL);\n\n\nvoid main() {\n	vec3 L = normalize(lightPos - worldPos);\n	vec3 V = normalize(camPos - worldPos);\n	vec3 N = getNormal0();\n	vec3 H = normalize(V + L);\n\n	vec3 ambient = texture(ambientMap, uv).rgb;\n\n	vec3 specular = texture(specularMap, uv).rgb * max(pow(dot(N, H), shininess), 0);\n\n	float NdotL = max(dot(N, L), 0);\n	vec3 diffuse = texture(diffuseMap, uv).rgb * NdotL;\n\n	float shadow = ShadowCalculation(worldPos, posInLight, lightPos, camPos, NdotL);\n\n	vec3 color = globalAmbience * ambient + (1 - shadow) * lightColor * (diffuse + specular);\n\n	fragColor = vec4(color, vert_in.color.a);\n}\n\n#pragma include(\"shadow.glsl\")\n";
const std::string screen_frag_shader = "#version 450 core \n\n\nlayout(binding = 0) uniform sampler2D image;\n\nin ncl_PerVertex{\n	smooth vec2 texCoord;\n};\n\nout vec4 fragColor;\n\nvoid main(){\n	fragColor = vec4(texture(image, texCoord).rgb, 1);\n}\n";
const std::string screen_vert_shader = "#version 450 core \n\n\nlayout(location = 0) in vec3 position;\nlayout(location = 5) in vec2 uv;\nlayout(location=8) in mat4 xform;\n\nout ncl_PerVertex{\n	smooth vec2 texCoord;\n};\n\nvoid main(){\n	texCoord = uv;\n	gl_Position =  xform * vec4(position, 1);\n}\n";
const std::string shadow_map_frag_shader = "#version 450 core \n\nvoid main(){\n	\n}\n";
const std::string shadow_map_vert_shader = "#version 450 core \n\nlayout(location = 0) in vec3 position;\nlayout(location=8) in mat4 xform;\n\nuniform mat4 M;\nuniform mat4 lightSpaceView; \n\nvoid main(){\n	gl_Position = lightSpaceView * M * xform * vec4(position, 1);\n}\n";
const std::string shadow_map_render_frag_shader = "#version 450 core\n\nin vec2 texCoord;\n\nlayout(binding = 0) uniform sampler2D shadowMap;\n\nuniform float near_plane;\nuniform float far_plane;\nuniform bool perspective;\n\nout vec4 fragColor;\n\nfloat LinearizeDepth(float depth){\n	    float z = depth * 2.0 - 1.0; // Back to NDC \n    return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));\n}\n\nvoid main(){\n	float depthValue = texture(shadowMap, texCoord).r;\n	depthValue = perspective ? LinearizeDepth(depthValue) : depthValue;\n\n	fragColor = vec4(vec3(depthValue), 1);\n}\n";
const std::string shadow_map_render_vert_shader = "#version 450 core\n\nlayout(location = 0) in vec3 position;\nlayout(location = 5) in vec2 uv;\n\nsmooth out vec2 texCoord;\n\nvoid main(){\n	texCoord = uv;\n	gl_Position = vec4(position, 1.0);\n}\n";
const std::string simple_light_frag_shader = "";
const std::string skybox_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(binding=0) uniform samplerCube skybox;\nsmooth in vec3 textCoord_out;\nout vec4 fragColor;\n\nvoid main(){\n	vec3 color = texture(skybox, textCoord_out).xyz;\n\n	color /= color + vec3(1.0);\n	color = pow(color, vec3(1.0/2.2));\n\n	fragColor = vec4(color, 1.0);\n}\n";
const std::string skybox_geom_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(triangles) in;\nlayout(triangle_strip, max_vertices = 3) out;\n\nuniform int id;\n\nsmooth in vec3 texCoord[3];\nsmooth out vec3 textCoord_out;\n\nvoid main(void)\n{\n	int n;\n	\n	for (n = 0; n < gl_in.length(); n++){\n		gl_ViewportIndex = id;\n		gl_Position = gl_in[n].gl_Position;\n		textCoord_out = texCoord[n];\n		EmitVertex();\n	}\n	EndPrimitive();\n}\n";
const std::string skybox_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\n\nlayout(location=0) in vec3 position;\nsmooth out vec3 texCoord;\n\nuniform mat4 M;\nuniform mat4 V;\nuniform mat4 P;\n\nvoid main(){\n	texCoord = position;\n	mat4 rotV = mat4(mat3(V));\n	vec4 pos = P * rotV * M * vec4(position, 1.0);\n	gl_Position = pos.xyww;\n}\n";
const std::string specular_convolution_vert_shader = "#version 450 core\n\nuniform mat4 MVP;\n\nlayout(location=0) in vec3 position;\n\nsmooth out vec3 localPos;\n\nvoid main(){\n	localPos = position;\n	gl_Position = MVP * vec4(localPos, 1.0);\n}\n";
const std::string speculuar_convolution_frag_shader = "#version 450 core\n\nlayout(binding = 0) uniform samplerCube environmentMap;\n\nuniform float roughness;\n\nout vec4 fragColor;\nsmooth in vec3 localPos;\nconst float PI = 3.14159265359;\n\n// ----------------------------------------------------------------------------\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\n// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n// efficient VanDerCorpus calculation.\nfloat RadicalInverse_VdC(uint bits) \n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n	return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n// ----------------------------------------------------------------------------\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n	float a = roughness*roughness;\n	\n	float phi = 2.0 * PI * Xi.x;\n	float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n	float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n	\n	// from spherical coordinates to cartesian coordinates - halfway vector\n	vec3 H;\n	H.x = cos(phi) * sinTheta;\n	H.y = sin(phi) * sinTheta;\n	H.z = cosTheta;\n	\n	// from tangent-space H vector to world-space sample vector\n	vec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n	vec3 tangent   = normalize(cross(up, N));\n	vec3 bitangent = cross(N, tangent);\n	\n	vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n	return normalize(sampleVec);\n}\n// ----------------------------------------------------------------------------\nvoid main()\n{		\n    vec3 N = normalize(localPos);\n    \n    // make the simplyfying assumption that V equals R equals the normal \n    vec3 R = N;\n    vec3 V = R;\n\n    const uint SAMPLE_COUNT = 1024u;\n    vec3 prefilteredColor = vec3(0.0);\n    float totalWeight = 0.0;\n    \n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        // generates a sample vector that's biased towards the preferred alignment direction (importance sampling).\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(dot(N, L), 0.0);\n        if(NdotL > 0.0)\n        {\n            // sample from the environment's mip level based on roughness/pdf\n            float D   = DistributionGGX(N, H, roughness);\n            float NdotH = max(dot(N, H), 0.0);\n            float HdotV = max(dot(H, V), 0.0);\n            float pdf = D * NdotH / (4.0 * HdotV) + 0.0001; \n\n            float resolution = 512.0; // resolution of source cubemap (per face)\n            float saTexel  = 4.0 * PI / (6.0 * resolution * resolution);\n            float saSample = 1.0 / (float(SAMPLE_COUNT) * pdf + 0.0001);\n\n            float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n            \n            prefilteredColor += textureLod(environmentMap, L, mipLevel).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n\n    prefilteredColor = prefilteredColor / totalWeight;\n\n    fragColor = vec4(prefilteredColor, 1.0);\n}\n";
const std::string teapot_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nin VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n	smooth vec4 lightDirection;\n} in_vertex;\nnoperspective in vec3 edgeDistance;\n\n\nout vec4 fragColor;\n\nvoid main(){\n	fragColor = in_vertex.color;\n}\n";
const std::string teapot_tcs_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nuniform int grids;\n\nlayout(vertices = 16) out;\n\nin VERTEX{\n	smooth vec4 color;\n} in_vertex[];\n\nout VERTEX{\n	smooth vec4 color;\n} out_vertex[];\n\nvoid main(){\n	gl_TessLevelOuter[0] = float(grids);\n	gl_TessLevelOuter[1] = float(grids);\n	gl_TessLevelOuter[2] = float(grids);\n	gl_TessLevelOuter[3] = float(grids);\n\n	gl_TessLevelInner[0] = float(grids);\n	gl_TessLevelInner[1] = float(grids);\n\n	out_vertex[gl_InvocationID].color = in_vertex[gl_InvocationID].color;\n\n	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;\n}\n";
const std::string teapot_tes_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout( quads, equal_spacing, ccw ) in;\n\nconst int MAX_LIGHT_SOURCES = 10;\n\nuniform mat4 LMV;\nuniform mat4 MV;\nuniform mat4 MVP;\nuniform mat3 normalMatrix;\n\nuniform struct LightSource{\n	vec4 position;\n	vec4 ambient;\n	vec4 diffuse;\n	vec4 specular;\n	vec4 spotDirection;\n	float spotAngle;\n	float spotExponent;\n	float kc;\n	float ki;\n	float kq;\n	bool transform;\n} light[MAX_LIGHT_SOURCES];\n\nin VERTEX{\n	smooth vec4 color;\n} in_vertex[];\n\nout VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n	smooth vec4 lightDirection[MAX_LIGHT_SOURCES];\n} out_vertex;\nnoperspective out vec3 edgeDistance;\n\n\nconst vec4 bc = vec4(1, 3, 3, 1);\n\nfloat B(int i,  float u){\n	return bc[i] * pow(1.0 - u, 3 - i) * pow(u, i);\n}\n\nvec4 getLightDirection(vec4 pos, in LightSource light){\n	if(light.position.w == 0){	// directional light\n		if(light.transform){\n			return normalize(LMV*light.position);\n		}\n		return normalize(light.position);\n	}\n	else{	// positional light\n		vec4 lightPos = (light.position/light.position.w);\n		if(light.transform){\n			return normalize((LMV*light.position) - pos);\n		}\n		return normalize(light.position - pos);\n	}\n}\n\nfloat partialD(int i,  float u){\n	float du[] = {\n		-3.0 * (1 - u) * (1 - u),\n		 -6.0 * u * (1-u) + 3.0 * (1-u) * (1-u),\n		 -3.0 * u * u + 6.0 * u * (1-u),\n		 3.0 * u * u\n	};\n	return du[i];\n}\n\nvoid main(){\n	float u = gl_TessCoord.x;\n	float v = gl_TessCoord.y;\n\n	vec4 p = vec4(0);\n	vec4 du = vec4(0);\n	vec4 dv = vec4(0);\n	for(int i = 0; i < 4; i++){\n		for(int j = 0; j < 4; j++){\n			p += B(i, u) * B(j, v) * gl_in[i * 4 + j].gl_Position; \n			du += partialD(i, u) * B(j, v) * gl_in[i * 4 + j].gl_Position; \n			dv += B(i, u) * partialD(j, v) * gl_in[i * 4 + j].gl_Position;\n		}\n	}\n\n	vec3 normal = normalize(cross(du.xyz, dv.xyz));\n	vec4 pos = MV * p;\n	out_vertex.position = pos.xyz;\n	for(int i = 0; i < light.length(); i++){\n		out_vertex.lightDirection[i] = getLightDirection(pos, light[i]);\n	}\n	out_vertex.texCoord = gl_TessCoord.xy;\n	out_vertex.normal = normalize(normalMatrix * normal);\n	out_vertex.color = in_vertex[0].color;\n	gl_Position = MVP * p;\n\n}\n";
const std::string teapot_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(location=0) in vec3 position;\nlayout(location=4) in vec4 color;\n\nout VERTEX{\n	smooth vec4 color;\n} out_vertex;\n\nvoid main(){\n	out_vertex.color = color;\n	gl_Position = vec4(position, 1);\n}\n";
const std::string texture_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout(binding = 0) uniform sampler2D image0;\nlayout(binding = 1) uniform sampler2D image1;\n\nin VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n} vertex;\n\nout vec4 fragColor;\n\nvoid main(){\n	vec4 color = texture(image0, vertex.texCoord);\n	vec4 oldLeather = texture(image1, vertex.texCoord);\n	fragColor = mix(color, oldLeather, 0.3);\n	fragColor = color;\n}\n";
const std::string ui_frag_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main(){\n	fragColor = color;\n}\n";
const std::string ui_vert_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nuniform mat4 MVP;\n\nlayout(location=0) in vec3 position;\n\nvoid main(){\n	gl_Position = MVP * vec4(position, 1);\n}\n";
const std::string viewport_point_glsl_shader = "#version 450 core\n#pragma degub(on)\n#pragma optimize(off)\n\nlayout(points) in;\n\nlayout(points, max_vertices = 1) out;\n\nuniform int id;\n\nin VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n} vertex_in[];\n\nout VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n} vertex_out;\n\n\nvoid main(){\n	for(int i = 0; i < gl_in.length(); i++){\n		gl_ViewportIndex = id;\n		gl_Position = gl_in[i].gl_Position;\n		vertex_out.position = vertex_in[i].position;\n		vertex_out.color = vertex_in[i].color;\n		vertex_out.texCoord = vertex_in[i].texCoord;\n		vertex_out.normal = vertex_in[i].normal;\n		EmitVertex();\n	}\n	EndPrimitive();\n}\n";
const std::string wireframe_geom_shader = "#version 450 core\n#pragma debug(on)\n#pragma optimize(off)\n\nlayout( triangles ) in;\nlayout( triangle_strip, max_vertices = 3) out;\n\nconst int MAX_LIGHT_SOURCES = 10;\n\nin VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n	smooth vec3 eyes;\n	smooth vec4 lightDirection[MAX_LIGHT_SOURCES];\n} in_vertex[];\n\nout VERTEX {\n	smooth vec3 position;\n	smooth vec3 normal;\n	smooth vec2 texCoord;\n	smooth vec4 color;\n	smooth vec3 eyes;\n	smooth vec4 lightDirection[MAX_LIGHT_SOURCES];\n} out_vertex;\n\nnoperspective out vec3 edgeDistance;\nuniform mat4 viewport;\n\nvoid main(){\n	vec3 p0 = (viewport * (gl_in[0].gl_Position / gl_in[0].gl_Position.w)).xyz;\n	vec3 p1 = (viewport * (gl_in[1].gl_Position / gl_in[1].gl_Position.w)).xyz;\n	vec3 p2 = (viewport * (gl_in[2].gl_Position / gl_in[2].gl_Position.w)).xyz;\n\n	// find the altitudes (ha, hb, hc)\n	float a = length(p1 - p2);\n	float b = length(p2 - p0);\n	float c = length(p1 - p0);\n	float alpha = acos((b*b + c*c - a*a) / (2.0*b*c));\n	float beta = acos((a*a + c*c - b*b) / (2.0*a*c));\n	float ha = abs( c * sin(beta));\n	float hb = abs( c * sin(alpha));\n	float hc = abs(b * sin(alpha));\n\n	// send the triangle along with the edge distances\n	edgeDistance = vec3(ha, 0, 0);\n	out_vertex.position = in_vertex[0].position;\n	out_vertex.normal = in_vertex[0].normal;\n	out_vertex.texCoord = in_vertex[0].texCoord;\n	out_vertex.eyes = in_vertex[0].eyes;\n	out_vertex.color = in_vertex[0].color;\n	\n\n	for(int i = 0; i < in_vertex[0].lightDirection.length(); i++){\n		out_vertex.lightDirection[i] = in_vertex[0].lightDirection[i];\n	}\n\n	gl_Position = gl_in[0].gl_Position;\n	EmitVertex();\n\n	edgeDistance = vec3(0, hb, 0);\n	out_vertex.position = in_vertex[1].position;\n	out_vertex.normal = in_vertex[1].normal;\n	out_vertex.texCoord = in_vertex[1].texCoord;\n	out_vertex.color = in_vertex[1].color;\n	out_vertex.eyes = in_vertex[1].eyes;\n	for(int i = 0; i < in_vertex[1].lightDirection.length(); i++){\n		out_vertex.lightDirection[i] = in_vertex[1].lightDirection[i];\n	}\n	gl_Position = gl_in[1].gl_Position;\n	EmitVertex();\n\n	edgeDistance = vec3(0, 0, hc);\n	out_vertex.position = in_vertex[2].position;\n	out_vertex.normal = in_vertex[2].normal;\n	out_vertex.texCoord = in_vertex[2].texCoord;\n	out_vertex.color = in_vertex[2].color;\n	out_vertex.eyes = in_vertex[2].eyes;\n	for(int i = 0; i < in_vertex[2].lightDirection.length(); i++){\n		out_vertex.lightDirection[i] = in_vertex[2].lightDirection[i];\n	}\n	gl_Position = gl_in[2].gl_Position;\n	EmitVertex();\n}\n";
