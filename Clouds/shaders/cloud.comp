#version 450 core

#define PI (3.1415926535897932384626433832795)
#define TWO_PI (6.283185307179586476925286766559)
#define RED (vec3(1, 0, 0))
#define GREEN (vec3(0, 1, 0))
#define BLUE (vec3(0, 0, 1))
#define BLACK (vec3(0, 0, 0))

const int MAX_SAMPLES = 10;
const float EPSILSON = 0.000001; 


struct Box{
	vec3 min;
	vec3 max;
};

struct Weather{
	float cloud_coverage;
	float cloud_type;
	float percipitation;
	vec3 wind_direciton;
	float cloud_speed;
};

struct Ray {
	vec3 origin;
	vec3 direction;
	float tMax;
};

struct Atmosphere{
	float innerRadius;
	float outerRadius;
};

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;


layout(rgba32f, binding=0) uniform image2D image;

layout(binding = 1) uniform sampler2D canvas;
layout(binding = 2) uniform sampler2D depthBuffer;

layout(binding = 3) uniform sampler3D cloudNoiseLowFreq;
layout(binding = 4) uniform sampler3D clouldNoiseHighFreq;

layout(std430, binding=1) buffer RAY_SSB0{
	Ray rays[];
};


uniform Weather weather;
uniform Atmosphere atmosphere;
uniform Box box;
uniform vec3 stepDelta;
uniform mat4 MVP;

bool intersectPlane(Ray ray, vec3 n, float d, out float t, out vec2 uv);

bool intersectCube(Ray ray, Box box, out vec2 uv, out vec3 p0, out vec3 p1, out float tn, out float tr);

vec3 Checkerboard(vec2 uv);

void orthonormalBasis(vec3 n, out vec3 x, out vec3 y);

int globalIndex();

bool intersectSphere(Ray ray, float radius, out vec3 p);

float saturate(float val);

float heightFractionForPoint(vec3 pos, Atmosphere atmosphere);

float densityHeightGradientForPoint(vec3 p, Atmosphere atmosphere, Weather weather);

float remap(float x, float a, float b, float c, float d);

float sampleCloudDensity(vec3 p, Weather weather, bool fullSample);

vec4 traceRay(Ray ray, Atmosphere atmosphere, Weather weather);

vec4 traceRay1(Ray ray, Atmosphere atmosphere, Weather weather);

vec4 test(vec2 uv);

float depthValue(vec3 p);

const vec2 fragCoord = vec2(gl_GlobalInvocationID.xy)/(vec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy) - vec2(1));

void main(){
	int index = globalIndex();
	Ray ray = rays[index];


	bool aHit = false;
	vec2 uv;
	float t = ray.tMax;
	float t0;
	vec4 color = vec4(0);
	color.a = 1;


	Box box = Box(vec3(-1), vec3(9));

	vec3 p0, p1;
	float t1;
	if(intersectCube(ray, box, uv, p0, p1, t0, t1)){
		aHit = true;
		if(t0 < t){
			t = t0;
			color.rgb = Checkerboard(uv);
		}
	}
	t0 = t0 < 0 ? t1/10 : t0;

	vec3 p = ray.origin + ray.direction * t0;
	float depthSrc = depthValue(p);
	float depthDest = texture(depthBuffer, fragCoord).r;
	if(aHit && depthSrc < depthDest){
		vec3 dest = texture(canvas, fragCoord).rgb;
		color.rgb = color.rgb + dest * (1 - color.a);
	}else{
		color.rgb = texture(canvas, fragCoord).rgb;
	}

	imageStore(image, ivec2(gl_GlobalInvocationID.xy), color);
}

int globalIndex(){
	ivec3 size = ivec3(gl_WorkGroupSize * gl_NumWorkGroups);
	ivec3 pos = ivec3(gl_GlobalInvocationID);

	return pos.z * (size.y * size.x) + (pos.y * size.x) + pos.x;
}

bool pointInBox(Box box, vec3 p){
	return dot(sign(p - box.min), sign(box.max -p)) == 3;
}


bool intersectCube(Ray ray, Box box, out vec2 uv, out vec3 p0, out vec3 p1, out float tn, out float tf) {	
	
	bvec3 rayParallelToSlab = lessThan(abs(ray.direction), vec3(EPSILSON));

	if(any(rayParallelToSlab) && !pointInBox(box, ray.origin)) return false;


	// TODO check what happens when min/max applied to Inf
	vec3   tMin = (box.min - ray.origin) / ray.direction;
	vec3   tMax = (box.max - ray.origin) / ray.direction;
	vec3     t1 = min(tMin, tMax);
	vec3     t2 = max(tMin, tMax);
	tn = max(max(t1.x, t1.y), t1.z);
	tf = min(min(t2.x, t2.y), t2.z);

	if (tn > ray.tMax || tf < 0) return false;

	p0 = ray.origin + tn * ray.direction;
	p1 = ray.origin + tf * ray.direction;
	vec3 n = -sign(ray.direction) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);
	vec3 x, y;
	n = tn < 0 ? -n : n;
	orthonormalBasis(n, x, y);
	
	vec3 p = tn < 0 ? p1 : p0;
	uv = vec2(dot(p, x)/5, dot(p, y)/5);
	uv = abs(uv);
	return tn < tf;
}

bool intersectPlane(Ray ray, vec3 n, float d, out float t, out vec2 uv) {

	t = d - dot(n, ray.origin);
	t /= dot(n, ray.direction);

	if (t < 0 || t > ray.tMax) {
		return false;
	}

	vec3 p = ray.origin + t * ray.direction;

	vec3 x, y;
	orthonormalBasis(n, x, y);
		
	//	interact.uv = vec2(p.x / whole, p.z / whole);
	uv = vec2(dot(p, x)/10, dot(p, y)/10);

	return true;
}


bool intersectSphere(Ray ray, float radius, out vec3 p){
	vec3 cs = vec3(0, 0, 0);
	vec3 m = ray.origin - cs;
	float b = dot(m, ray.direction);
	float c = dot(m , m) - radius * radius;

	// ray is facing away from sphere
	if(c > 0 && b > 0) return false;

	float discr = b * b - c;

	// sqrt(-discr) imaginary number corresponds to ray missing sphere
	if(discr < 0) return false; 

	float t = 0;
	t = -b - sqrt(discr);
	
	p = ray.origin + ray.direction * t;

	return true;
}

float saturate(float val){
	return clamp(val, 0.0, 1.0);
}


float heightFractionForPoint(vec3 pos, Atmosphere atmosphere){
	float height_fraction = (pos.y - atmosphere.innerRadius);
	height_fraction /= (atmosphere.outerRadius - atmosphere.innerRadius);

	//return saturate(height_fraction);
	return 0.5;
}

float densityHeightGradientForPoint(vec3 p, Atmosphere atmosphere, Weather weather){
	
	float height = heightFractionForPoint(p, atmosphere);
	float cloud_type = weather.cloud_type;

	const vec4 stratusGrad = vec4(0.02f, 0.05f, 0.09f, 0.11f);
	const vec4 stratocumulusGrad = vec4(0.02f, 0.2f, 0.48f, 0.625f);
	const vec4 cumulusGrad = vec4(0.01f, 0.0625f, 0.78f, 1.0f);
	float stratus = 1.0f - clamp(cloud_type * 2.0f, 0, 1);
	float stratocumulus = 1.0f - abs(cloud_type - 0.5f) * 2.0f;
	float cumulus = clamp(cloud_type - 0.5f, 0, 1) * 2.0f;
	vec4 cloudGradient = stratusGrad * stratus + stratocumulusGrad * stratocumulus + cumulusGrad * cumulus;
	return smoothstep(cloudGradient.x, cloudGradient.y, height) - smoothstep(cloudGradient.z, cloudGradient.w, height);
}

float remap(float x, float a, float b, float c, float d){
	return (((x - a) / (b - a)) * (d - c)) + c;
}

vec3 remap(vec3 x, vec3 a, vec3 b, vec3 c, vec3 d){
	return (((x - a) / (b - a)) * (d - c)) + c;
}

float sampleCloudDensity(vec3 p, Atmosphere atmosphere, Weather weather, bool cheapSamples){
	
	//vec3 voxelCoord = remap(p, vec3(atmosphere.innerRadius), vec3(atmosphere.outerRadius), vec3(0.0), vec3(1.0));
	vec3 voxelCoord = p;

	vec4 low_frequency_noise = textureLod(cloudNoiseLowFreq, voxelCoord, 0);
	float perlinWorley = low_frequency_noise.r;
	vec3 worley_low_freq = low_frequency_noise.gba;
	float low_freq_fbm = dot(worley_low_freq, vec3(0.625, 0.25, 0.125));

	float base_cloud = remap(perlinWorley, low_freq_fbm - 1.0, 1.0, 0.0, 1.0);

	float density_height_grad = densityHeightGradientForPoint(p, atmosphere, weather);

	base_cloud *= density_height_grad;


	float cloud_coverage = weather.cloud_coverage;

	float base_cloud_with_coverage = remap(base_cloud, cloud_coverage, 1.0, 0.0, 1.0);

	base_cloud_with_coverage *= cloud_coverage;

	return base_cloud_with_coverage;
}

vec4 traceRay(Ray ray, Atmosphere atmosphere, Weather weather){

	return vec4(sampleCloudDensity(ray.direction, atmosphere, weather, false));

	vec3 startPosition;
	bool aboveInnerAtmosphere = dot(ray.origin, ray.origin) > pow(atmosphere.innerRadius, 2);

//	if(aboveInnerAtmosphere){	
//		startPosition = ray.origin;
//	}else if(!intersectSphere(ray, atmosphere.innerRadius, startPosition)){
//		return vec4(1, 0, 0, 0);
//	}
	

	if(!intersectSphere(ray, atmosphere.innerRadius, startPosition)){
		return vec4(0);
	}

	//vec3 stepDelta = ray.direction * ((atmosphere.outerRadius - atmosphere.innerRadius)/MAX_SAMPLES);
	vec3 stepDelta = ray.direction * (1.0/MAX_SAMPLES);
	vec3 p = startPosition;
	float density = 0.0;
	float cloud_test = 0.0;
	int zero_density_sample_count = 0;
	const bool cheapSamples = true;
	const bool expensiveSamples = false;

	for(int i = 0; i < MAX_SAMPLES; i++){
	//	bool aboveOuterAtmosphere = dot(p, p) > pow(atmosphere.outerRadius, 2);

	//	if(aboveOuterAtmosphere) break;

		if(density > 0.99) break;

		if(cloud_test > 0.0){
			float sampled_density = sampleCloudDensity(p, atmosphere, weather, expensiveSamples);
			zero_density_sample_count += (sampled_density == 0.0 ? 1 : 0);
			
			if(zero_density_sample_count != 6){
				density += sampled_density;
				p += stepDelta;
			}else{
				cloud_test = 0.0;
				zero_density_sample_count = 0;
				break;
			}
		}else{
			cloud_test = sampleCloudDensity(p, atmosphere, weather, cheapSamples);
			if(cloud_test == 0.0){
				p += stepDelta;
			}
		}
	}

	return vec4(density);
}

uniform float dt;

void orthonormalBasis(vec3 n, out vec3 x, out vec3 y) {
	float s = n.z >= 0.0 ? 1.0 : -1.0;
	float a = -1.0 / (s + n.z);
	float b = n.x * n.y * a;
	x = vec3(1.0 + s * n.x * n.x * a, s * b, -s * n.x);
	y = vec3(b, s + n.y * n.y * a, -n.y);
}

vec3 Checkerboard(vec2 uv)
{
	return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);
}

float sampleCloud(vec3 pos){

	float perlinWorley = texture(cloudNoiseLowFreq, pos).x;
	vec3 worley = texture(cloudNoiseLowFreq, pos).yzw;

	float wfbm = dot(worley, vec3(0.625, 0.125, 0.25));

    // cloud shape modeled after the GPU Pro 7 chapter
    float cloud = remap(perlinWorley, wfbm - 1.0, 1.0, 0.0, 1.0);
    cloud = remap(cloud, 0.85, 1.0, 0., 1.0); // fake cloud coverage
	cloud = cloud < 0 ? 0 : cloud;

	return cloud;
}

vec4 traceRay1(Ray ray, Atmosphere atmosphere, Weather weather){
	vec2 uv;
	vec3 p0;
	vec3 p1;
	float t;
	if(intersectPlane(ray, vec3(1, 0, 0), 0, t, uv)){
		return vec4(Checkerboard(uv), 1);
	}


	return vec4(0);
}

float depthValue(vec3 p){
	vec4 pos = MVP * vec4(p, 1);

	if(pos.w == 0) return 1;

	// apply perspective division
	float d = pos.z/pos.w;

	// outside NDC [-1, 1]
	if(d < -1 || d > 1) return 1;

	// remap from NDC [-1, 1] to screen space [0, 1]
	return d * 0.5 + 0.5;
}